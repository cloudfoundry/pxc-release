// Code generated by counterfeiter. DO NOT EDIT.
package db_helperfakes

import (
	"os/exec"
	"sync"

	"github.com/cloudfoundry/galera-init/db_helper"
)

type FakeDBHelper struct {
	IsDatabaseReachableStub        func() bool
	isDatabaseReachableMutex       sync.RWMutex
	isDatabaseReachableArgsForCall []struct {
	}
	isDatabaseReachableReturns struct {
		result1 bool
	}
	isDatabaseReachableReturnsOnCall map[int]struct {
		result1 bool
	}
	IsDatabaseSyncedStub        func() bool
	isDatabaseSyncedMutex       sync.RWMutex
	isDatabaseSyncedArgsForCall []struct {
	}
	isDatabaseSyncedReturns struct {
		result1 bool
	}
	isDatabaseSyncedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsProcessRunningStub        func() bool
	isProcessRunningMutex       sync.RWMutex
	isProcessRunningArgsForCall []struct {
	}
	isProcessRunningReturns struct {
		result1 bool
	}
	isProcessRunningReturnsOnCall map[int]struct {
		result1 bool
	}
	SetVariableStub        func(string, any) error
	setVariableMutex       sync.RWMutex
	setVariableArgsForCall []struct {
		arg1 string
		arg2 any
	}
	setVariableReturns struct {
		result1 error
	}
	setVariableReturnsOnCall map[int]struct {
		result1 error
	}
	StartMysqldInBootstrapStub        func() (*exec.Cmd, error)
	startMysqldInBootstrapMutex       sync.RWMutex
	startMysqldInBootstrapArgsForCall []struct {
	}
	startMysqldInBootstrapReturns struct {
		result1 *exec.Cmd
		result2 error
	}
	startMysqldInBootstrapReturnsOnCall map[int]struct {
		result1 *exec.Cmd
		result2 error
	}
	StartMysqldInJoinStub        func() (*exec.Cmd, error)
	startMysqldInJoinMutex       sync.RWMutex
	startMysqldInJoinArgsForCall []struct {
	}
	startMysqldInJoinReturns struct {
		result1 *exec.Cmd
		result2 error
	}
	startMysqldInJoinReturnsOnCall map[int]struct {
		result1 *exec.Cmd
		result2 error
	}
	StopMysqldStub        func()
	stopMysqldMutex       sync.RWMutex
	stopMysqldArgsForCall []struct {
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDBHelper) IsDatabaseReachable() bool {
	fake.isDatabaseReachableMutex.Lock()
	ret, specificReturn := fake.isDatabaseReachableReturnsOnCall[len(fake.isDatabaseReachableArgsForCall)]
	fake.isDatabaseReachableArgsForCall = append(fake.isDatabaseReachableArgsForCall, struct {
	}{})
	stub := fake.IsDatabaseReachableStub
	fakeReturns := fake.isDatabaseReachableReturns
	fake.recordInvocation("IsDatabaseReachable", []interface{}{})
	fake.isDatabaseReachableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) IsDatabaseReachableCallCount() int {
	fake.isDatabaseReachableMutex.RLock()
	defer fake.isDatabaseReachableMutex.RUnlock()
	return len(fake.isDatabaseReachableArgsForCall)
}

func (fake *FakeDBHelper) IsDatabaseReachableCalls(stub func() bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = stub
}

func (fake *FakeDBHelper) IsDatabaseReachableReturns(result1 bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = nil
	fake.isDatabaseReachableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsDatabaseReachableReturnsOnCall(i int, result1 bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = nil
	if fake.isDatabaseReachableReturnsOnCall == nil {
		fake.isDatabaseReachableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDatabaseReachableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsDatabaseSynced() bool {
	fake.isDatabaseSyncedMutex.Lock()
	ret, specificReturn := fake.isDatabaseSyncedReturnsOnCall[len(fake.isDatabaseSyncedArgsForCall)]
	fake.isDatabaseSyncedArgsForCall = append(fake.isDatabaseSyncedArgsForCall, struct {
	}{})
	stub := fake.IsDatabaseSyncedStub
	fakeReturns := fake.isDatabaseSyncedReturns
	fake.recordInvocation("IsDatabaseSynced", []interface{}{})
	fake.isDatabaseSyncedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) IsDatabaseSyncedCallCount() int {
	fake.isDatabaseSyncedMutex.RLock()
	defer fake.isDatabaseSyncedMutex.RUnlock()
	return len(fake.isDatabaseSyncedArgsForCall)
}

func (fake *FakeDBHelper) IsDatabaseSyncedCalls(stub func() bool) {
	fake.isDatabaseSyncedMutex.Lock()
	defer fake.isDatabaseSyncedMutex.Unlock()
	fake.IsDatabaseSyncedStub = stub
}

func (fake *FakeDBHelper) IsDatabaseSyncedReturns(result1 bool) {
	fake.isDatabaseSyncedMutex.Lock()
	defer fake.isDatabaseSyncedMutex.Unlock()
	fake.IsDatabaseSyncedStub = nil
	fake.isDatabaseSyncedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsDatabaseSyncedReturnsOnCall(i int, result1 bool) {
	fake.isDatabaseSyncedMutex.Lock()
	defer fake.isDatabaseSyncedMutex.Unlock()
	fake.IsDatabaseSyncedStub = nil
	if fake.isDatabaseSyncedReturnsOnCall == nil {
		fake.isDatabaseSyncedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDatabaseSyncedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsProcessRunning() bool {
	fake.isProcessRunningMutex.Lock()
	ret, specificReturn := fake.isProcessRunningReturnsOnCall[len(fake.isProcessRunningArgsForCall)]
	fake.isProcessRunningArgsForCall = append(fake.isProcessRunningArgsForCall, struct {
	}{})
	stub := fake.IsProcessRunningStub
	fakeReturns := fake.isProcessRunningReturns
	fake.recordInvocation("IsProcessRunning", []interface{}{})
	fake.isProcessRunningMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) IsProcessRunningCallCount() int {
	fake.isProcessRunningMutex.RLock()
	defer fake.isProcessRunningMutex.RUnlock()
	return len(fake.isProcessRunningArgsForCall)
}

func (fake *FakeDBHelper) IsProcessRunningCalls(stub func() bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = stub
}

func (fake *FakeDBHelper) IsProcessRunningReturns(result1 bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = nil
	fake.isProcessRunningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsProcessRunningReturnsOnCall(i int, result1 bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = nil
	if fake.isProcessRunningReturnsOnCall == nil {
		fake.isProcessRunningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isProcessRunningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) SetVariable(arg1 string, arg2 any) error {
	fake.setVariableMutex.Lock()
	ret, specificReturn := fake.setVariableReturnsOnCall[len(fake.setVariableArgsForCall)]
	fake.setVariableArgsForCall = append(fake.setVariableArgsForCall, struct {
		arg1 string
		arg2 any
	}{arg1, arg2})
	stub := fake.SetVariableStub
	fakeReturns := fake.setVariableReturns
	fake.recordInvocation("SetVariable", []interface{}{arg1, arg2})
	fake.setVariableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) SetVariableCallCount() int {
	fake.setVariableMutex.RLock()
	defer fake.setVariableMutex.RUnlock()
	return len(fake.setVariableArgsForCall)
}

func (fake *FakeDBHelper) SetVariableCalls(stub func(string, any) error) {
	fake.setVariableMutex.Lock()
	defer fake.setVariableMutex.Unlock()
	fake.SetVariableStub = stub
}

func (fake *FakeDBHelper) SetVariableArgsForCall(i int) (string, any) {
	fake.setVariableMutex.RLock()
	defer fake.setVariableMutex.RUnlock()
	argsForCall := fake.setVariableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDBHelper) SetVariableReturns(result1 error) {
	fake.setVariableMutex.Lock()
	defer fake.setVariableMutex.Unlock()
	fake.SetVariableStub = nil
	fake.setVariableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) SetVariableReturnsOnCall(i int, result1 error) {
	fake.setVariableMutex.Lock()
	defer fake.setVariableMutex.Unlock()
	fake.SetVariableStub = nil
	if fake.setVariableReturnsOnCall == nil {
		fake.setVariableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setVariableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) StartMysqldInBootstrap() (*exec.Cmd, error) {
	fake.startMysqldInBootstrapMutex.Lock()
	ret, specificReturn := fake.startMysqldInBootstrapReturnsOnCall[len(fake.startMysqldInBootstrapArgsForCall)]
	fake.startMysqldInBootstrapArgsForCall = append(fake.startMysqldInBootstrapArgsForCall, struct {
	}{})
	stub := fake.StartMysqldInBootstrapStub
	fakeReturns := fake.startMysqldInBootstrapReturns
	fake.recordInvocation("StartMysqldInBootstrap", []interface{}{})
	fake.startMysqldInBootstrapMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDBHelper) StartMysqldInBootstrapCallCount() int {
	fake.startMysqldInBootstrapMutex.RLock()
	defer fake.startMysqldInBootstrapMutex.RUnlock()
	return len(fake.startMysqldInBootstrapArgsForCall)
}

func (fake *FakeDBHelper) StartMysqldInBootstrapCalls(stub func() (*exec.Cmd, error)) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = stub
}

func (fake *FakeDBHelper) StartMysqldInBootstrapReturns(result1 *exec.Cmd, result2 error) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = nil
	fake.startMysqldInBootstrapReturns = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInBootstrapReturnsOnCall(i int, result1 *exec.Cmd, result2 error) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = nil
	if fake.startMysqldInBootstrapReturnsOnCall == nil {
		fake.startMysqldInBootstrapReturnsOnCall = make(map[int]struct {
			result1 *exec.Cmd
			result2 error
		})
	}
	fake.startMysqldInBootstrapReturnsOnCall[i] = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInJoin() (*exec.Cmd, error) {
	fake.startMysqldInJoinMutex.Lock()
	ret, specificReturn := fake.startMysqldInJoinReturnsOnCall[len(fake.startMysqldInJoinArgsForCall)]
	fake.startMysqldInJoinArgsForCall = append(fake.startMysqldInJoinArgsForCall, struct {
	}{})
	stub := fake.StartMysqldInJoinStub
	fakeReturns := fake.startMysqldInJoinReturns
	fake.recordInvocation("StartMysqldInJoin", []interface{}{})
	fake.startMysqldInJoinMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDBHelper) StartMysqldInJoinCallCount() int {
	fake.startMysqldInJoinMutex.RLock()
	defer fake.startMysqldInJoinMutex.RUnlock()
	return len(fake.startMysqldInJoinArgsForCall)
}

func (fake *FakeDBHelper) StartMysqldInJoinCalls(stub func() (*exec.Cmd, error)) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = stub
}

func (fake *FakeDBHelper) StartMysqldInJoinReturns(result1 *exec.Cmd, result2 error) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = nil
	fake.startMysqldInJoinReturns = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInJoinReturnsOnCall(i int, result1 *exec.Cmd, result2 error) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = nil
	if fake.startMysqldInJoinReturnsOnCall == nil {
		fake.startMysqldInJoinReturnsOnCall = make(map[int]struct {
			result1 *exec.Cmd
			result2 error
		})
	}
	fake.startMysqldInJoinReturnsOnCall[i] = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StopMysqld() {
	fake.stopMysqldMutex.Lock()
	fake.stopMysqldArgsForCall = append(fake.stopMysqldArgsForCall, struct {
	}{})
	stub := fake.StopMysqldStub
	fake.recordInvocation("StopMysqld", []interface{}{})
	fake.stopMysqldMutex.Unlock()
	if stub != nil {
		fake.StopMysqldStub()
	}
}

func (fake *FakeDBHelper) StopMysqldCallCount() int {
	fake.stopMysqldMutex.RLock()
	defer fake.stopMysqldMutex.RUnlock()
	return len(fake.stopMysqldArgsForCall)
}

func (fake *FakeDBHelper) StopMysqldCalls(stub func()) {
	fake.stopMysqldMutex.Lock()
	defer fake.stopMysqldMutex.Unlock()
	fake.StopMysqldStub = stub
}

func (fake *FakeDBHelper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isDatabaseReachableMutex.RLock()
	defer fake.isDatabaseReachableMutex.RUnlock()
	fake.isDatabaseSyncedMutex.RLock()
	defer fake.isDatabaseSyncedMutex.RUnlock()
	fake.isProcessRunningMutex.RLock()
	defer fake.isProcessRunningMutex.RUnlock()
	fake.setVariableMutex.RLock()
	defer fake.setVariableMutex.RUnlock()
	fake.startMysqldInBootstrapMutex.RLock()
	defer fake.startMysqldInBootstrapMutex.RUnlock()
	fake.startMysqldInJoinMutex.RLock()
	defer fake.startMysqldInJoinMutex.RUnlock()
	fake.stopMysqldMutex.RLock()
	defer fake.stopMysqldMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDBHelper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db_helper.DBHelper = new(FakeDBHelper)
