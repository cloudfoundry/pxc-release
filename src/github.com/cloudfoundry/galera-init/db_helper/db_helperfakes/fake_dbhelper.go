// Code generated by counterfeiter. DO NOT EDIT.
package db_helperfakes

import (
	"os/exec"
	"sync"

	"github.com/cloudfoundry/galera-init/db_helper"
)

type FakeDBHelper struct {
	IsDatabaseReachableStub        func() bool
	isDatabaseReachableMutex       sync.RWMutex
	isDatabaseReachableArgsForCall []struct {
	}
	isDatabaseReachableReturns struct {
		result1 bool
	}
	isDatabaseReachableReturnsOnCall map[int]struct {
		result1 bool
	}
	IsProcessRunningStub        func() bool
	isProcessRunningMutex       sync.RWMutex
	isProcessRunningArgsForCall []struct {
	}
	isProcessRunningReturns struct {
		result1 bool
	}
	isProcessRunningReturnsOnCall map[int]struct {
		result1 bool
	}
	RunPostStartSQLStub        func() error
	runPostStartSQLMutex       sync.RWMutex
	runPostStartSQLArgsForCall []struct {
	}
	runPostStartSQLReturns struct {
		result1 error
	}
	runPostStartSQLReturnsOnCall map[int]struct {
		result1 error
	}
	SeedStub        func() error
	seedMutex       sync.RWMutex
	seedArgsForCall []struct {
	}
	seedReturns struct {
		result1 error
	}
	seedReturnsOnCall map[int]struct {
		result1 error
	}
	SeedUsersStub        func() error
	seedUsersMutex       sync.RWMutex
	seedUsersArgsForCall []struct {
	}
	seedUsersReturns struct {
		result1 error
	}
	seedUsersReturnsOnCall map[int]struct {
		result1 error
	}
	StartMysqldForUpgradeStub        func() (*exec.Cmd, error)
	startMysqldForUpgradeMutex       sync.RWMutex
	startMysqldForUpgradeArgsForCall []struct {
	}
	startMysqldForUpgradeReturns struct {
		result1 *exec.Cmd
		result2 error
	}
	startMysqldForUpgradeReturnsOnCall map[int]struct {
		result1 *exec.Cmd
		result2 error
	}
	StartMysqldInBootstrapStub        func() (*exec.Cmd, error)
	startMysqldInBootstrapMutex       sync.RWMutex
	startMysqldInBootstrapArgsForCall []struct {
	}
	startMysqldInBootstrapReturns struct {
		result1 *exec.Cmd
		result2 error
	}
	startMysqldInBootstrapReturnsOnCall map[int]struct {
		result1 *exec.Cmd
		result2 error
	}
	StartMysqldInJoinStub        func() (*exec.Cmd, error)
	startMysqldInJoinMutex       sync.RWMutex
	startMysqldInJoinArgsForCall []struct {
	}
	startMysqldInJoinReturns struct {
		result1 *exec.Cmd
		result2 error
	}
	startMysqldInJoinReturnsOnCall map[int]struct {
		result1 *exec.Cmd
		result2 error
	}
	StopMysqldStub        func()
	stopMysqldMutex       sync.RWMutex
	stopMysqldArgsForCall []struct {
	}
	UpgradeStub        func() (string, error)
	upgradeMutex       sync.RWMutex
	upgradeArgsForCall []struct {
	}
	upgradeReturns struct {
		result1 string
		result2 error
	}
	upgradeReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDBHelper) IsDatabaseReachable() bool {
	fake.isDatabaseReachableMutex.Lock()
	ret, specificReturn := fake.isDatabaseReachableReturnsOnCall[len(fake.isDatabaseReachableArgsForCall)]
	fake.isDatabaseReachableArgsForCall = append(fake.isDatabaseReachableArgsForCall, struct {
	}{})
	stub := fake.IsDatabaseReachableStub
	fakeReturns := fake.isDatabaseReachableReturns
	fake.recordInvocation("IsDatabaseReachable", []interface{}{})
	fake.isDatabaseReachableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) IsDatabaseReachableCallCount() int {
	fake.isDatabaseReachableMutex.RLock()
	defer fake.isDatabaseReachableMutex.RUnlock()
	return len(fake.isDatabaseReachableArgsForCall)
}

func (fake *FakeDBHelper) IsDatabaseReachableCalls(stub func() bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = stub
}

func (fake *FakeDBHelper) IsDatabaseReachableReturns(result1 bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = nil
	fake.isDatabaseReachableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsDatabaseReachableReturnsOnCall(i int, result1 bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = nil
	if fake.isDatabaseReachableReturnsOnCall == nil {
		fake.isDatabaseReachableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDatabaseReachableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsProcessRunning() bool {
	fake.isProcessRunningMutex.Lock()
	ret, specificReturn := fake.isProcessRunningReturnsOnCall[len(fake.isProcessRunningArgsForCall)]
	fake.isProcessRunningArgsForCall = append(fake.isProcessRunningArgsForCall, struct {
	}{})
	stub := fake.IsProcessRunningStub
	fakeReturns := fake.isProcessRunningReturns
	fake.recordInvocation("IsProcessRunning", []interface{}{})
	fake.isProcessRunningMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) IsProcessRunningCallCount() int {
	fake.isProcessRunningMutex.RLock()
	defer fake.isProcessRunningMutex.RUnlock()
	return len(fake.isProcessRunningArgsForCall)
}

func (fake *FakeDBHelper) IsProcessRunningCalls(stub func() bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = stub
}

func (fake *FakeDBHelper) IsProcessRunningReturns(result1 bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = nil
	fake.isProcessRunningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsProcessRunningReturnsOnCall(i int, result1 bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = nil
	if fake.isProcessRunningReturnsOnCall == nil {
		fake.isProcessRunningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isProcessRunningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) RunPostStartSQL() error {
	fake.runPostStartSQLMutex.Lock()
	ret, specificReturn := fake.runPostStartSQLReturnsOnCall[len(fake.runPostStartSQLArgsForCall)]
	fake.runPostStartSQLArgsForCall = append(fake.runPostStartSQLArgsForCall, struct {
	}{})
	stub := fake.RunPostStartSQLStub
	fakeReturns := fake.runPostStartSQLReturns
	fake.recordInvocation("RunPostStartSQL", []interface{}{})
	fake.runPostStartSQLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) RunPostStartSQLCallCount() int {
	fake.runPostStartSQLMutex.RLock()
	defer fake.runPostStartSQLMutex.RUnlock()
	return len(fake.runPostStartSQLArgsForCall)
}

func (fake *FakeDBHelper) RunPostStartSQLCalls(stub func() error) {
	fake.runPostStartSQLMutex.Lock()
	defer fake.runPostStartSQLMutex.Unlock()
	fake.RunPostStartSQLStub = stub
}

func (fake *FakeDBHelper) RunPostStartSQLReturns(result1 error) {
	fake.runPostStartSQLMutex.Lock()
	defer fake.runPostStartSQLMutex.Unlock()
	fake.RunPostStartSQLStub = nil
	fake.runPostStartSQLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) RunPostStartSQLReturnsOnCall(i int, result1 error) {
	fake.runPostStartSQLMutex.Lock()
	defer fake.runPostStartSQLMutex.Unlock()
	fake.RunPostStartSQLStub = nil
	if fake.runPostStartSQLReturnsOnCall == nil {
		fake.runPostStartSQLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runPostStartSQLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) Seed() error {
	fake.seedMutex.Lock()
	ret, specificReturn := fake.seedReturnsOnCall[len(fake.seedArgsForCall)]
	fake.seedArgsForCall = append(fake.seedArgsForCall, struct {
	}{})
	stub := fake.SeedStub
	fakeReturns := fake.seedReturns
	fake.recordInvocation("Seed", []interface{}{})
	fake.seedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) SeedCallCount() int {
	fake.seedMutex.RLock()
	defer fake.seedMutex.RUnlock()
	return len(fake.seedArgsForCall)
}

func (fake *FakeDBHelper) SeedCalls(stub func() error) {
	fake.seedMutex.Lock()
	defer fake.seedMutex.Unlock()
	fake.SeedStub = stub
}

func (fake *FakeDBHelper) SeedReturns(result1 error) {
	fake.seedMutex.Lock()
	defer fake.seedMutex.Unlock()
	fake.SeedStub = nil
	fake.seedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) SeedReturnsOnCall(i int, result1 error) {
	fake.seedMutex.Lock()
	defer fake.seedMutex.Unlock()
	fake.SeedStub = nil
	if fake.seedReturnsOnCall == nil {
		fake.seedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.seedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) SeedUsers() error {
	fake.seedUsersMutex.Lock()
	ret, specificReturn := fake.seedUsersReturnsOnCall[len(fake.seedUsersArgsForCall)]
	fake.seedUsersArgsForCall = append(fake.seedUsersArgsForCall, struct {
	}{})
	stub := fake.SeedUsersStub
	fakeReturns := fake.seedUsersReturns
	fake.recordInvocation("SeedUsers", []interface{}{})
	fake.seedUsersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDBHelper) SeedUsersCallCount() int {
	fake.seedUsersMutex.RLock()
	defer fake.seedUsersMutex.RUnlock()
	return len(fake.seedUsersArgsForCall)
}

func (fake *FakeDBHelper) SeedUsersCalls(stub func() error) {
	fake.seedUsersMutex.Lock()
	defer fake.seedUsersMutex.Unlock()
	fake.SeedUsersStub = stub
}

func (fake *FakeDBHelper) SeedUsersReturns(result1 error) {
	fake.seedUsersMutex.Lock()
	defer fake.seedUsersMutex.Unlock()
	fake.SeedUsersStub = nil
	fake.seedUsersReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) SeedUsersReturnsOnCall(i int, result1 error) {
	fake.seedUsersMutex.Lock()
	defer fake.seedUsersMutex.Unlock()
	fake.SeedUsersStub = nil
	if fake.seedUsersReturnsOnCall == nil {
		fake.seedUsersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.seedUsersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDBHelper) StartMysqldForUpgrade() (*exec.Cmd, error) {
	fake.startMysqldForUpgradeMutex.Lock()
	ret, specificReturn := fake.startMysqldForUpgradeReturnsOnCall[len(fake.startMysqldForUpgradeArgsForCall)]
	fake.startMysqldForUpgradeArgsForCall = append(fake.startMysqldForUpgradeArgsForCall, struct {
	}{})
	stub := fake.StartMysqldForUpgradeStub
	fakeReturns := fake.startMysqldForUpgradeReturns
	fake.recordInvocation("StartMysqldForUpgrade", []interface{}{})
	fake.startMysqldForUpgradeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDBHelper) StartMysqldForUpgradeCallCount() int {
	fake.startMysqldForUpgradeMutex.RLock()
	defer fake.startMysqldForUpgradeMutex.RUnlock()
	return len(fake.startMysqldForUpgradeArgsForCall)
}

func (fake *FakeDBHelper) StartMysqldForUpgradeCalls(stub func() (*exec.Cmd, error)) {
	fake.startMysqldForUpgradeMutex.Lock()
	defer fake.startMysqldForUpgradeMutex.Unlock()
	fake.StartMysqldForUpgradeStub = stub
}

func (fake *FakeDBHelper) StartMysqldForUpgradeReturns(result1 *exec.Cmd, result2 error) {
	fake.startMysqldForUpgradeMutex.Lock()
	defer fake.startMysqldForUpgradeMutex.Unlock()
	fake.StartMysqldForUpgradeStub = nil
	fake.startMysqldForUpgradeReturns = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldForUpgradeReturnsOnCall(i int, result1 *exec.Cmd, result2 error) {
	fake.startMysqldForUpgradeMutex.Lock()
	defer fake.startMysqldForUpgradeMutex.Unlock()
	fake.StartMysqldForUpgradeStub = nil
	if fake.startMysqldForUpgradeReturnsOnCall == nil {
		fake.startMysqldForUpgradeReturnsOnCall = make(map[int]struct {
			result1 *exec.Cmd
			result2 error
		})
	}
	fake.startMysqldForUpgradeReturnsOnCall[i] = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInBootstrap() (*exec.Cmd, error) {
	fake.startMysqldInBootstrapMutex.Lock()
	ret, specificReturn := fake.startMysqldInBootstrapReturnsOnCall[len(fake.startMysqldInBootstrapArgsForCall)]
	fake.startMysqldInBootstrapArgsForCall = append(fake.startMysqldInBootstrapArgsForCall, struct {
	}{})
	stub := fake.StartMysqldInBootstrapStub
	fakeReturns := fake.startMysqldInBootstrapReturns
	fake.recordInvocation("StartMysqldInBootstrap", []interface{}{})
	fake.startMysqldInBootstrapMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDBHelper) StartMysqldInBootstrapCallCount() int {
	fake.startMysqldInBootstrapMutex.RLock()
	defer fake.startMysqldInBootstrapMutex.RUnlock()
	return len(fake.startMysqldInBootstrapArgsForCall)
}

func (fake *FakeDBHelper) StartMysqldInBootstrapCalls(stub func() (*exec.Cmd, error)) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = stub
}

func (fake *FakeDBHelper) StartMysqldInBootstrapReturns(result1 *exec.Cmd, result2 error) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = nil
	fake.startMysqldInBootstrapReturns = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInBootstrapReturnsOnCall(i int, result1 *exec.Cmd, result2 error) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = nil
	if fake.startMysqldInBootstrapReturnsOnCall == nil {
		fake.startMysqldInBootstrapReturnsOnCall = make(map[int]struct {
			result1 *exec.Cmd
			result2 error
		})
	}
	fake.startMysqldInBootstrapReturnsOnCall[i] = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInJoin() (*exec.Cmd, error) {
	fake.startMysqldInJoinMutex.Lock()
	ret, specificReturn := fake.startMysqldInJoinReturnsOnCall[len(fake.startMysqldInJoinArgsForCall)]
	fake.startMysqldInJoinArgsForCall = append(fake.startMysqldInJoinArgsForCall, struct {
	}{})
	stub := fake.StartMysqldInJoinStub
	fakeReturns := fake.startMysqldInJoinReturns
	fake.recordInvocation("StartMysqldInJoin", []interface{}{})
	fake.startMysqldInJoinMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDBHelper) StartMysqldInJoinCallCount() int {
	fake.startMysqldInJoinMutex.RLock()
	defer fake.startMysqldInJoinMutex.RUnlock()
	return len(fake.startMysqldInJoinArgsForCall)
}

func (fake *FakeDBHelper) StartMysqldInJoinCalls(stub func() (*exec.Cmd, error)) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = stub
}

func (fake *FakeDBHelper) StartMysqldInJoinReturns(result1 *exec.Cmd, result2 error) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = nil
	fake.startMysqldInJoinReturns = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInJoinReturnsOnCall(i int, result1 *exec.Cmd, result2 error) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = nil
	if fake.startMysqldInJoinReturnsOnCall == nil {
		fake.startMysqldInJoinReturnsOnCall = make(map[int]struct {
			result1 *exec.Cmd
			result2 error
		})
	}
	fake.startMysqldInJoinReturnsOnCall[i] = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StopMysqld() {
	fake.stopMysqldMutex.Lock()
	fake.stopMysqldArgsForCall = append(fake.stopMysqldArgsForCall, struct {
	}{})
	stub := fake.StopMysqldStub
	fake.recordInvocation("StopMysqld", []interface{}{})
	fake.stopMysqldMutex.Unlock()
	if stub != nil {
		fake.StopMysqldStub()
	}
}

func (fake *FakeDBHelper) StopMysqldCallCount() int {
	fake.stopMysqldMutex.RLock()
	defer fake.stopMysqldMutex.RUnlock()
	return len(fake.stopMysqldArgsForCall)
}

func (fake *FakeDBHelper) StopMysqldCalls(stub func()) {
	fake.stopMysqldMutex.Lock()
	defer fake.stopMysqldMutex.Unlock()
	fake.StopMysqldStub = stub
}

func (fake *FakeDBHelper) Upgrade() (string, error) {
	fake.upgradeMutex.Lock()
	ret, specificReturn := fake.upgradeReturnsOnCall[len(fake.upgradeArgsForCall)]
	fake.upgradeArgsForCall = append(fake.upgradeArgsForCall, struct {
	}{})
	stub := fake.UpgradeStub
	fakeReturns := fake.upgradeReturns
	fake.recordInvocation("Upgrade", []interface{}{})
	fake.upgradeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDBHelper) UpgradeCallCount() int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return len(fake.upgradeArgsForCall)
}

func (fake *FakeDBHelper) UpgradeCalls(stub func() (string, error)) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = stub
}

func (fake *FakeDBHelper) UpgradeReturns(result1 string, result2 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	fake.upgradeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) UpgradeReturnsOnCall(i int, result1 string, result2 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	if fake.upgradeReturnsOnCall == nil {
		fake.upgradeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.upgradeReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isDatabaseReachableMutex.RLock()
	defer fake.isDatabaseReachableMutex.RUnlock()
	fake.isProcessRunningMutex.RLock()
	defer fake.isProcessRunningMutex.RUnlock()
	fake.runPostStartSQLMutex.RLock()
	defer fake.runPostStartSQLMutex.RUnlock()
	fake.seedMutex.RLock()
	defer fake.seedMutex.RUnlock()
	fake.seedUsersMutex.RLock()
	defer fake.seedUsersMutex.RUnlock()
	fake.startMysqldForUpgradeMutex.RLock()
	defer fake.startMysqldForUpgradeMutex.RUnlock()
	fake.startMysqldInBootstrapMutex.RLock()
	defer fake.startMysqldInBootstrapMutex.RUnlock()
	fake.startMysqldInJoinMutex.RLock()
	defer fake.startMysqldInJoinMutex.RUnlock()
	fake.stopMysqldMutex.RLock()
	defer fake.stopMysqldMutex.RUnlock()
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDBHelper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db_helper.DBHelper = new(FakeDBHelper)
