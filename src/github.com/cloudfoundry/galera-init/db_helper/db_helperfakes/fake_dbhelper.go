// Code generated by counterfeiter. DO NOT EDIT.
package db_helperfakes

import (
	"os/exec"
	"sync"

	"github.com/cloudfoundry/galera-init/db_helper"
)

type FakeDBHelper struct {
	IsDatabaseReachableStub        func() bool
	isDatabaseReachableMutex       sync.RWMutex
	isDatabaseReachableArgsForCall []struct {
	}
	isDatabaseReachableReturns struct {
		result1 bool
	}
	isDatabaseReachableReturnsOnCall map[int]struct {
		result1 bool
	}
	IsProcessRunningStub        func() bool
	isProcessRunningMutex       sync.RWMutex
	isProcessRunningArgsForCall []struct {
	}
	isProcessRunningReturns struct {
		result1 bool
	}
	isProcessRunningReturnsOnCall map[int]struct {
		result1 bool
	}
	StartMysqldInBootstrapStub        func() (*exec.Cmd, error)
	startMysqldInBootstrapMutex       sync.RWMutex
	startMysqldInBootstrapArgsForCall []struct {
	}
	startMysqldInBootstrapReturns struct {
		result1 *exec.Cmd
		result2 error
	}
	startMysqldInBootstrapReturnsOnCall map[int]struct {
		result1 *exec.Cmd
		result2 error
	}
	StartMysqldInJoinStub        func() (*exec.Cmd, error)
	startMysqldInJoinMutex       sync.RWMutex
	startMysqldInJoinArgsForCall []struct {
	}
	startMysqldInJoinReturns struct {
		result1 *exec.Cmd
		result2 error
	}
	startMysqldInJoinReturnsOnCall map[int]struct {
		result1 *exec.Cmd
		result2 error
	}
	StopMysqldStub        func()
	stopMysqldMutex       sync.RWMutex
	stopMysqldArgsForCall []struct {
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDBHelper) IsDatabaseReachable() bool {
	fake.isDatabaseReachableMutex.Lock()
	ret, specificReturn := fake.isDatabaseReachableReturnsOnCall[len(fake.isDatabaseReachableArgsForCall)]
	fake.isDatabaseReachableArgsForCall = append(fake.isDatabaseReachableArgsForCall, struct {
	}{})
	fake.recordInvocation("IsDatabaseReachable", []interface{}{})
	fake.isDatabaseReachableMutex.Unlock()
	if fake.IsDatabaseReachableStub != nil {
		return fake.IsDatabaseReachableStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isDatabaseReachableReturns
	return fakeReturns.result1
}

func (fake *FakeDBHelper) IsDatabaseReachableCallCount() int {
	fake.isDatabaseReachableMutex.RLock()
	defer fake.isDatabaseReachableMutex.RUnlock()
	return len(fake.isDatabaseReachableArgsForCall)
}

func (fake *FakeDBHelper) IsDatabaseReachableCalls(stub func() bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = stub
}

func (fake *FakeDBHelper) IsDatabaseReachableReturns(result1 bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = nil
	fake.isDatabaseReachableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsDatabaseReachableReturnsOnCall(i int, result1 bool) {
	fake.isDatabaseReachableMutex.Lock()
	defer fake.isDatabaseReachableMutex.Unlock()
	fake.IsDatabaseReachableStub = nil
	if fake.isDatabaseReachableReturnsOnCall == nil {
		fake.isDatabaseReachableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDatabaseReachableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsProcessRunning() bool {
	fake.isProcessRunningMutex.Lock()
	ret, specificReturn := fake.isProcessRunningReturnsOnCall[len(fake.isProcessRunningArgsForCall)]
	fake.isProcessRunningArgsForCall = append(fake.isProcessRunningArgsForCall, struct {
	}{})
	fake.recordInvocation("IsProcessRunning", []interface{}{})
	fake.isProcessRunningMutex.Unlock()
	if fake.IsProcessRunningStub != nil {
		return fake.IsProcessRunningStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isProcessRunningReturns
	return fakeReturns.result1
}

func (fake *FakeDBHelper) IsProcessRunningCallCount() int {
	fake.isProcessRunningMutex.RLock()
	defer fake.isProcessRunningMutex.RUnlock()
	return len(fake.isProcessRunningArgsForCall)
}

func (fake *FakeDBHelper) IsProcessRunningCalls(stub func() bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = stub
}

func (fake *FakeDBHelper) IsProcessRunningReturns(result1 bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = nil
	fake.isProcessRunningReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) IsProcessRunningReturnsOnCall(i int, result1 bool) {
	fake.isProcessRunningMutex.Lock()
	defer fake.isProcessRunningMutex.Unlock()
	fake.IsProcessRunningStub = nil
	if fake.isProcessRunningReturnsOnCall == nil {
		fake.isProcessRunningReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isProcessRunningReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDBHelper) StartMysqldInBootstrap() (*exec.Cmd, error) {
	fake.startMysqldInBootstrapMutex.Lock()
	ret, specificReturn := fake.startMysqldInBootstrapReturnsOnCall[len(fake.startMysqldInBootstrapArgsForCall)]
	fake.startMysqldInBootstrapArgsForCall = append(fake.startMysqldInBootstrapArgsForCall, struct {
	}{})
	fake.recordInvocation("StartMysqldInBootstrap", []interface{}{})
	fake.startMysqldInBootstrapMutex.Unlock()
	if fake.StartMysqldInBootstrapStub != nil {
		return fake.StartMysqldInBootstrapStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.startMysqldInBootstrapReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDBHelper) StartMysqldInBootstrapCallCount() int {
	fake.startMysqldInBootstrapMutex.RLock()
	defer fake.startMysqldInBootstrapMutex.RUnlock()
	return len(fake.startMysqldInBootstrapArgsForCall)
}

func (fake *FakeDBHelper) StartMysqldInBootstrapCalls(stub func() (*exec.Cmd, error)) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = stub
}

func (fake *FakeDBHelper) StartMysqldInBootstrapReturns(result1 *exec.Cmd, result2 error) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = nil
	fake.startMysqldInBootstrapReturns = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInBootstrapReturnsOnCall(i int, result1 *exec.Cmd, result2 error) {
	fake.startMysqldInBootstrapMutex.Lock()
	defer fake.startMysqldInBootstrapMutex.Unlock()
	fake.StartMysqldInBootstrapStub = nil
	if fake.startMysqldInBootstrapReturnsOnCall == nil {
		fake.startMysqldInBootstrapReturnsOnCall = make(map[int]struct {
			result1 *exec.Cmd
			result2 error
		})
	}
	fake.startMysqldInBootstrapReturnsOnCall[i] = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInJoin() (*exec.Cmd, error) {
	fake.startMysqldInJoinMutex.Lock()
	ret, specificReturn := fake.startMysqldInJoinReturnsOnCall[len(fake.startMysqldInJoinArgsForCall)]
	fake.startMysqldInJoinArgsForCall = append(fake.startMysqldInJoinArgsForCall, struct {
	}{})
	fake.recordInvocation("StartMysqldInJoin", []interface{}{})
	fake.startMysqldInJoinMutex.Unlock()
	if fake.StartMysqldInJoinStub != nil {
		return fake.StartMysqldInJoinStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.startMysqldInJoinReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDBHelper) StartMysqldInJoinCallCount() int {
	fake.startMysqldInJoinMutex.RLock()
	defer fake.startMysqldInJoinMutex.RUnlock()
	return len(fake.startMysqldInJoinArgsForCall)
}

func (fake *FakeDBHelper) StartMysqldInJoinCalls(stub func() (*exec.Cmd, error)) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = stub
}

func (fake *FakeDBHelper) StartMysqldInJoinReturns(result1 *exec.Cmd, result2 error) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = nil
	fake.startMysqldInJoinReturns = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StartMysqldInJoinReturnsOnCall(i int, result1 *exec.Cmd, result2 error) {
	fake.startMysqldInJoinMutex.Lock()
	defer fake.startMysqldInJoinMutex.Unlock()
	fake.StartMysqldInJoinStub = nil
	if fake.startMysqldInJoinReturnsOnCall == nil {
		fake.startMysqldInJoinReturnsOnCall = make(map[int]struct {
			result1 *exec.Cmd
			result2 error
		})
	}
	fake.startMysqldInJoinReturnsOnCall[i] = struct {
		result1 *exec.Cmd
		result2 error
	}{result1, result2}
}

func (fake *FakeDBHelper) StopMysqld() {
	fake.stopMysqldMutex.Lock()
	fake.stopMysqldArgsForCall = append(fake.stopMysqldArgsForCall, struct {
	}{})
	fake.recordInvocation("StopMysqld", []interface{}{})
	fake.stopMysqldMutex.Unlock()
	if fake.StopMysqldStub != nil {
		fake.StopMysqldStub()
	}
}

func (fake *FakeDBHelper) StopMysqldCallCount() int {
	fake.stopMysqldMutex.RLock()
	defer fake.stopMysqldMutex.RUnlock()
	return len(fake.stopMysqldArgsForCall)
}

func (fake *FakeDBHelper) StopMysqldCalls(stub func()) {
	fake.stopMysqldMutex.Lock()
	defer fake.stopMysqldMutex.Unlock()
	fake.StopMysqldStub = stub
}

func (fake *FakeDBHelper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isDatabaseReachableMutex.RLock()
	defer fake.isDatabaseReachableMutex.RUnlock()
	fake.isProcessRunningMutex.RLock()
	defer fake.isProcessRunningMutex.RUnlock()
	fake.startMysqldInBootstrapMutex.RLock()
	defer fake.startMysqldInBootstrapMutex.RUnlock()
	fake.startMysqldInJoinMutex.RLock()
	defer fake.startMysqldInJoinMutex.RUnlock()
	fake.stopMysqldMutex.RLock()
	defer fake.stopMysqldMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDBHelper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db_helper.DBHelper = new(FakeDBHelper)
